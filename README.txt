Sdi1800180 Damianos Skartsilas Εργασία 1 Συστηματικός Προγραμματισμός 2024 
--------------------------------------------------------------------------------------------------------------------------------
Compilation:  
make
-------------------------------------------------------------
Execution: 
./jobCommander  <  > ( με ορίσματα [ issueJob <job>  | exit | set concurrency <x> | poll [running|queued] | stop job__XX]  )

(δηλαδή πρέπει να υπαρχει όρισμα/ορίσματα) (Ωστόσο αν δεν υπάρχει κανένα όρισμα ο user ειδοποιείται καταλλήλως)
Μετά την εκτέλεση του jobCommander περιμένουμε ώστε να δεκτεί μήνυμα μέσω pipe από τον Server. Τότε τερματίζεται ο Commander, όπως ζητήθηκε. Έτσι μπορούμε να τον ξαναεκτελέσουμε με νέα εντολή. 
Προτείνεται να ανοίξουμε νέο τερματικό ώστε να βλέπουμε ξεχωριστά την συμεπριφορά του jοbExecutorServer.

Αν θέλουμε να εκκινήσουμε πρώτα τον server αντί να το κάνει ο Commander : 

./jobExecutorServer 
ή με valgrind για να δούμε memory leaks (στην συγκεκριμένη περίπτωση δεν υπάρχουν)
valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./jobExecutorServer

και ύστερα να εισάγουμε εντολές μέσω εκτέλεσης του jobCommander


Μετά την εκτέλεση του jobCommander περιμένουμε ώστε να δεκτεί μήνυμα μέσω pipe από τον Server. Τότε τερματίζεται ο Commander, όπως ζητήθηκε. Έτσι μπορούμε να τον ξαναεκτελέσουμε.
μπορούμε να εκτελέσουμε επίσης multijob.sh <file.txt> ώστε να εισάγουμε μαζικά εντολές στον Server 
Εκτέλεση bash: (ΔΕΝ γίνονται compile sto makefile. για compile : chmod +x multijob.sh και chmod +x allJobsStop.sh) 
: ./multijob.sh <file2.txt> και ./allJobsStop.sh
--------------------------------------------------------------------------------------------------------------------------------
Η Εφαρμογή αποτελείται απο δύο κύρια προγράμματα υλοποιημένα σε C++.
(jobCommander.cpp και jobExecutorServer.cpp).
Περιλαμβάνεται το bash script multijob.sh και το bash script allJobsStop.sh
Επίσης περιλαμβάνεται Makefile το οποίο μεταγλωττίζει τα δύο αυτά προγράμματα (seperate compilation) και το bash script , σε εκτελέσιμα.

Η υλοποίηση έχει γίνει ως εξής:
ο jobCommander εξετάζει αν υπάρχει jobExecutorServer.txt στο directory, ώστε να "καταλαβει" αν ο Server είναι ενεργός. Αν δεν είναι τότε εκτελεί ο ίδιος τον Server μέσω fork  και execv ( ) κλήσεις συστήματος. Έχουν κληθεί sleep(1) ώστε να περιμένει το ένα πρόγραμμα το άλλο και να μην υπάρχουν επιπλοκές στην επικοινωνία μέσω pipes.
Ο Commander παίρνει το pid του Server από το txt και του στέλνει μέσω kill signal ώστε να προειδοποιήσει τον Server ότι θα στείλει εντολή.

jobExecutorServer υλοποίηση:
 
Έχει δηλωθεί η κλάση Job η οποία παριστάνει μία job σύμφωνα με τα πρότυπα της εκφώνησης.
Περιλαμβάνονται διάφορες συναρτήσεις get/set . Γίνεται χρήση queue η οποία είναι δηλωμένη στην βιβλιοθήκη STL. Κάθε queue είναι τύπου Job.
Χρησιμοποιούμε μία κύρια ουρά που έχει χρησιμότητα αναμονής, και μία για να τοποθετούμε τα job που τρέχουν την τάδε χρονική στιγμή.
Γίνεται η απαραίτητη ενημέρωση των ουρών καθ’ολη τη διάρκεια της λειτουργίας του Server. 

Η λειτουργικότητα έχει ως εξής: Η main ξεκινάει με τη δημιουργία txt αρχείου και γράφει εκεί το process id της παρούσας διεργασίας. Ύστερα αναμένει signal SIGUSR1 το οποίο το διαχειρίζεται μέσω handler sig_usr1. Εκει ανοίγει το pipe που ο Commander έγραψε την εντολή. Κατόπιν την περνάει στη συνάρτηση executeCommand. 
Εντός της executeCommand αν η εντολή είναι issueJοb  , καλείται η συνάρτηση executeJob. Σε αυτή τη συνάρτηση καλούμε fork ώστε να δημιουργήσουμε διεργασία παιδί η οποία με τη σειρά της  θα εκτελέσει την επιθυμητή εντολή μέσω execvp( ) .
Στην parent process μέσω signal(SIGCHLD, handler_sigchld) καλούμε τον handler του σήματος τερματισμού της διεργασίας παιδί. Εντός του handler αυτού θα καλέσουμε thn waitpid με τις κατάλληλες παραμέτρους ώστε να τσεκάρουμε αν η διεργασία παιδί τερματίστηκε ομαλά ή μέσω σήματος (πχ SIGKILL που στέλνουμε όταν η εντολή είναι stop).

Γενικότερα έχει υλοποιηθεί η συμπεριφορά που περιγράφεται στην εκφώνηση και υπάρχουν αντίστοιχα σχόλια στον κώδικα προκειμένου να γίνεται αντιληπτή η χρησιμότητα των συναρτήσεων.

Bash SCritps: Στο 1ο bash Στο 2ο bash , ξεκινάμε με την αφαίρεση των job που είναι στην αναμονή, ώστε μετά να απομείνουν για stop όσες ήδη έτρεχαν . Αν κάναμε πρώτα τερματισμό αυτών που τρέχουν τότε θα κάναμε διπλή δουλειά γιατί κατόπιν μπορει΄να έμπαιναν στο run δουλειές που ήταν σε αναμονή.
